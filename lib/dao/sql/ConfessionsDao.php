<?php
namespace lib\dao\sql;
use lib\datamodel\sql\Confessions;// Generated automatically by daogen.
// Do NOT edit this file.
// Any changes made to this file will be overwritten the next time it is generated.

class ConfessionsDao {
	public static $ALLOWED_QUERY_OPERATORS = array('=', '<', '<=', '>', '>=', 'beginsWith', 'contains', 'endsWith');
	public static $ALLOWED_NUMERIC_QUERY_OPERATORS = array('=', '<', '<=', '>', '>=');
	public static $ALLOWED_STRING_QUERY_OPERATORS = array('=', '<', '<=', '>', '>=', 'beginsWith', 'contains', 'endsWith');
	protected $connection;

	public function __construct($connection) {
		$this->connection = $connection;
	}

	public function insert($Confessions) {
		$ps = new PreparedStatement("insert into Confessions (src_ip, author, title, body, timestamp) values (?, ?, ?, ?, ?)");
		$ps->setInt($Confessions->src_ip);
		$ps->setString($Confessions->author);
		$ps->setString($Confessions->title);
		$ps->setString($Confessions->body);
		$ps->setInt($Confessions->timestamp);
		$this->connection->executeUpdate($ps);
		$Confessions->id = $this->connection->getLastInsertId();
	}

	public function update($Confessions) {
		$ps = new PreparedStatement("update Confessions set src_ip = ?, author = ?, title = ?, body = ?, timestamp = ? where id = ?");
		$ps->setInt($Confessions->src_ip);
		$ps->setString($Confessions->author);
		$ps->setString($Confessions->title);
		$ps->setString($Confessions->body);
		$ps->setInt($Confessions->timestamp);
		$ps->setInt($Confessions->id);
		$this->connection->executeUpdate($ps);
	}

	public function delete($id) {
		$ps = new PreparedStatement("delete from Confessions where id = ?");
		$ps->setInt($id);
		$this->connection->executeUpdate($ps);
	}

	public function load($id) {
		$ps = new PreparedStatement("select * from Confessions where id = ?");
		$ps->setInt($id);
		$arr = $this->connection->fetchArray($this->connection->executeQuery($ps), true);
		if ($arr === false) return false;
		$Confessions = new Confessions();
		$Confessions->loadFromArray($arr);
		return $Confessions;
	}

	public function findByIdPS($id, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		if (!in_array($queryOperator, ConfessionsDao::$ALLOWED_NUMERIC_QUERY_OPERATORS)) $queryOperator = ConfessionsDao::$ALLOWED_NUMERIC_QUERY_OPERATORS[0];
		$ps = new PreparedStatement("select * from Confessions where id $queryOperator ?".((($orderBy!==null)&&($orderBy!='')) ? (' order by '.$orderBy) : ''), $offset, $limit);
		$ps->setInt($id);
		return $ps;
	}

	public function findById($id, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		return $this->findWithPreparedStatement($this->findByIdPS($id, $queryOperator, $orderBy, $offset, $limit));
	}

	public function findBySrc_ipPS($src_ip, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		if (!in_array($queryOperator, ConfessionsDao::$ALLOWED_NUMERIC_QUERY_OPERATORS)) $queryOperator = ConfessionsDao::$ALLOWED_NUMERIC_QUERY_OPERATORS[0];
		$ps = new PreparedStatement("select * from Confessions where src_ip $queryOperator ?".((($orderBy!==null)&&($orderBy!='')) ? (' order by '.$orderBy) : ''), $offset, $limit);
		$ps->setInt($src_ip);
		return $ps;
	}

	public function findBySrc_ip($src_ip, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		return $this->findWithPreparedStatement($this->findBySrc_ipPS($src_ip, $queryOperator, $orderBy, $offset, $limit));
	}

	public function findByAuthorPS($author, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		if (!in_array($queryOperator, ConfessionsDao::$ALLOWED_STRING_QUERY_OPERATORS)) $queryOperator = ConfessionsDao::$ALLOWED_STRING_QUERY_OPERATORS[0];
		$sqlQueryOperator = (($queryOperator == 'beginsWith') || ($queryOperator == 'endsWith') || ($queryOperator == 'contains')) ? 'like' : $queryOperator;
		$ps = new PreparedStatement("select * from Confessions where author $sqlQueryOperator ?".((($orderBy!==null)&&($orderBy!='')) ? (' order by '.$orderBy) : ''), $offset, $limit);
		if ($queryOperator == 'beginsWith') {
			$ps->setString($author.'%');
		} else if ($queryOperator == 'endsWith') {
			$ps->setString('%'.$author);
		} else if ($queryOperator == 'contains') {
			$ps->setString('%'.$author.'%');
		} else {
			$ps->setString($author);
		}
		return $ps;
	}

	public function findByAuthor($author, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		return $this->findWithPreparedStatement($this->findByAuthorPS($author, $queryOperator, $orderBy, $offset, $limit));
	}

	public function findByTitlePS($title, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		if (!in_array($queryOperator, ConfessionsDao::$ALLOWED_STRING_QUERY_OPERATORS)) $queryOperator = ConfessionsDao::$ALLOWED_STRING_QUERY_OPERATORS[0];
		$sqlQueryOperator = (($queryOperator == 'beginsWith') || ($queryOperator == 'endsWith') || ($queryOperator == 'contains')) ? 'like' : $queryOperator;
		$ps = new PreparedStatement("select * from Confessions where title $sqlQueryOperator ?".((($orderBy!==null)&&($orderBy!='')) ? (' order by '.$orderBy) : ''), $offset, $limit);
		if ($queryOperator == 'beginsWith') {
			$ps->setString($title.'%');
		} else if ($queryOperator == 'endsWith') {
			$ps->setString('%'.$title);
		} else if ($queryOperator == 'contains') {
			$ps->setString('%'.$title.'%');
		} else {
			$ps->setString($title);
		}
		return $ps;
	}

	public function findByTitle($title, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		return $this->findWithPreparedStatement($this->findByTitlePS($title, $queryOperator, $orderBy, $offset, $limit));
	}

	public function findByBodyPS($body, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		if (!in_array($queryOperator, ConfessionsDao::$ALLOWED_STRING_QUERY_OPERATORS)) $queryOperator = ConfessionsDao::$ALLOWED_STRING_QUERY_OPERATORS[0];
		$sqlQueryOperator = (($queryOperator == 'beginsWith') || ($queryOperator == 'endsWith') || ($queryOperator == 'contains')) ? 'like' : $queryOperator;
		$ps = new PreparedStatement("select * from Confessions where body $sqlQueryOperator ?".((($orderBy!==null)&&($orderBy!='')) ? (' order by '.$orderBy) : ''), $offset, $limit);
		if ($queryOperator == 'beginsWith') {
			$ps->setString($body.'%');
		} else if ($queryOperator == 'endsWith') {
			$ps->setString('%'.$body);
		} else if ($queryOperator == 'contains') {
			$ps->setString('%'.$body.'%');
		} else {
			$ps->setString($body);
		}
		return $ps;
	}

	public function findByBody($body, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		return $this->findWithPreparedStatement($this->findByBodyPS($body, $queryOperator, $orderBy, $offset, $limit));
	}

	public function findByTimestampPS($timestamp, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		if (!in_array($queryOperator, ConfessionsDao::$ALLOWED_NUMERIC_QUERY_OPERATORS)) $queryOperator = ConfessionsDao::$ALLOWED_NUMERIC_QUERY_OPERATORS[0];
		$ps = new PreparedStatement("select * from Confessions where timestamp $queryOperator ?".((($orderBy!==null)&&($orderBy!='')) ? (' order by '.$orderBy) : ''), $offset, $limit);
		$ps->setInt($timestamp);
		return $ps;
	}

	public function findByTimestamp($timestamp, $queryOperator = '=', $orderBy = null, $offset = 0, $limit = 0) {
		return $this->findWithPreparedStatement($this->findByTimestampPS($timestamp, $queryOperator, $orderBy, $offset, $limit));
	}

	public function findAllPS($orderBy = null, $offset = 0, $limit = 0) {
		$ps = new PreparedStatement("select * from Confessions".((($orderBy!==null)&&($orderBy!='')) ? (' order by '.$orderBy) : ''), $offset, $limit);
		return $ps;
	}

	public function findAll($orderBy = null, $offset = 0, $limit = 0) {
		return $this->findWithPreparedStatement($this->findAllPS($orderBy, $offset, $limit));
	}

	public function findWithPreparedStatement($ps) {
		return ConfessionsDao::loadAllFromResultSet($this->connection, $this->connection->executeQuery($ps), true);
	}

	public static function loadAllFromResultSet($connection, $rs, $freeResultBeforeReturn = false) {
		$rows = array();
		while ($arr = $connection->fetchArray($rs)) {
			$Confessions = new Confessions();
			$Confessions->loadFromArray($arr);
			$rows[] = $Confessions;
		}
		if ($freeResultBeforeReturn) $connection->freeResult($rs);
		return $rows;
	}
}
